apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: validate-deployment
spec:
  crd:
    spec:
      names:
        kind: validate-deployment
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package main
        
        
        name = input.review.object.metadata.name
        
        namespace = input.review.object.metadata.namespace
        
        spec = input.review.object.spec
        
        template_spec = input.review.object.spec.template.spec
        
        containers = input.review.object.spec.template.spec.containers
        
        first_container = input.review.object.spec.template.spec.containers[0]
        
        ports = input.review.object.spec.template.spec.containers[0].ports
        
        jolokia = {
        	"containerPort": 8778,
        	"name": "jolokia",
        	"protocol": "TCP",
        }
        
        not_needed_for_jolokia = ["mysql"]
        
        jolokia_is_in_list(list) {
        	list[_] = jolokia
        }
        
        required_selector_labels {
        	spec.selector.matchLabels.app
        }
        
        violation[{"msg": msg}] {
        	not name
        
        	msg := sprintf("deployment %v has no name provided", [name])
        }
        
        violation[{"msg": msg}] {
        	not namespace
        
        	msg := sprintf("deployment %v has no namespace provided", [name])
        }
        
        violation[{"msg": msg}] {
        	not required_selector_labels
        
        	msg := sprintf("Does not contain label app in deployment %v", [name])
        }
        
        violation[{"msg": msg}] {
        	not containers
        
        	msg := sprintf("Deployment %v has no containers provided", [name])
        }
        
        violation[{"msg": msg}] {
        	not template_spec.terminationGracePeriodSeconds
        
        	msg := sprintf("Deployment %v has no terminationGracePeriodSeconds provided which should be there for a graceful shutdown", [name])
        }
        
        warn_high_terminationgraceperiodseconds[msg] {
        	template_spec.terminationGracePeriodSeconds > 50
        
        	msg := sprintf("Deployment %v has a terminationGracePeriodSeconds above 50 seconds (reality: %v). This could lead to a long waiting before SIGKILL", [name, template_spec.terminationGracePeriodSeconds])
        }
        
        warn_more_than_one_container[msg] {
        	not count(containers) <= 1
        
        	msg = sprintf("deployment %v has more than one container. Should not be done due to scaling. Use it wisely.", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.name
        
        	msg := sprintf("at least one container in deployment %v has no name", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.image
        
        	msg := sprintf("at least one container in deployment %v has no image", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.imagePullPolicy
        
        	msg := sprintf("at least one container in deployment %v has no imagePullPolicy", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources
        
        	msg := sprintf("at least one container in deployment %v has no resources section", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources.limits
        
        	msg := sprintf("at least one container in deployment %v has no resources limits section", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources.requests
        
        	msg := sprintf("at least one container in deployment %v has no resources requests section", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources.limits.memory
        
        	msg := sprintf("at least one container in deployment %v has no memory limits section", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources.requests.memory
        
        	msg := sprintf("at least one container in deployment %v has no memory requests section", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.resources.requests.cpu
        
        	msg := sprintf("at least one container in deployment %v has no cpu requests section", [name])
        }
        
        violation[{"msg": msg}] {
        	not template_spec.affinity
        
        	msg = sprintf("deployment %v does not have an affinity section", [name])
        }
        
        violation[{"msg": msg}] {
        	not template_spec.affinity.podAntiAffinity
        
        	msg = sprintf("deployment %v does not have an podAnitAffinity section", [name])
        }
        
        violation[{"msg": msg}] {
        	image := input.review.object.spec.template.spec.containers[_].image
        	not startswith_in_list(image, trusted_registries)
        
        	msg := sprintf("at least one containerimage in deployment %v is not from the allowed source", [name])
        }
        
        violation[{"msg": msg}] {
        	imagetag := split(input.review.object.spec.template.spec.containers[_].image, "@")
        	count(imagetag) == 1
        
        	msg := sprintf("imagetags are used instead of hash for deployment %v", [name])
        }
        
        violation[{"msg": msg}] {
        	imagetag := split(input.review.object.spec.template.spec.containers[_].image, "@")[1]
        	not startswith(imagetag, "sha256")
        
        	msg := sprintf("use sha256 instead of tagname to prevent usage of multiple pushed images for deployment %v", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	not container.securityContext
        
        	msg := sprintf("at least one container in deployment %v is missing securityContext", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	container.securityContext
        	container.securityContext.privileged
        
        	msg := sprintf("at least one container in deployment %v is privileged which is not allowed", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	container.securityContext
        	not container.securityContext.readOnlyRootFilesystem
        
        	msg := sprintf("at least one container in deployment %v has a writable Filesystem", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	container.securityContext
        	container.securityContext.allowPrivilegeEscalation
        
        	msg := sprintf("at least one container in deployment %v allows privilege escalation", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	container.securityContext
        	not container.securityContext.runAsNonRoot
        
        	msg := sprintf("at least one container in deployment %v has the permission to be executed as root.", [name])
        }
        
        violation[{"msg": msg}] {
        	container := template_spec.containers[_]
        	container.securityContext
        	not container.securityContext.capabilities
        
        	msg := sprintf("at least one container in deployment %v is not removing linux capabilities via securityContext.capabilities", [name])
        }
        
        violation[{"msg": msg}] {
        	not exists_in_list(name, serviceaccount_needed)
        	not template_spec.automountServiceAccountToken == false
        
        	msg := sprintf("deployment %v uses the automounted serviceaccount but doesn't need to. Please disable it with automountServiceAccountToken: false ", [name])
        }
        
        violation[{"msg": msg}] {
        	exists_in_list(name, serviceaccount_needed)
        	template_spec.serviceAccountName == "default"
        	template_spec.automountServiceAccountToken == false
        
        	msg := sprintf("deployment %v has the automount of serviceaccounts disabled. The set serviceAccountName will not be used.", [name])
        }
        
        violation[{"msg": msg}] {
        	exists_in_list(name, serviceaccount_needed)
        	template_spec.serviceAccountName == "default"
        	not template_spec.automountServiceAccountToken == false
        
        	msg := sprintf("deployment %v uses the default serviceaccount. Please create a separate one based on Least Privilege.", [name])
        }
        
        violation[{"msg": msg}] {
        	emptyDir := template_spec.volumes[_].emptyDir
        	not emptyDir.sizeLimit
        
        	msg := sprintf("at least one emptydir volume in deployment %v does not have a sizelimit ", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.livenessProbe
        
        	msg := sprintf("at least one container in deployment %v does not have a livenessprobe", [name])
        }
        
        violation[{"msg": msg}] {
        	container := input.review.object.spec.template.spec.containers[_]
        	not container.readinessProbe
        
        	msg := sprintf("at least one container in deployment %v does not have a readinessprobe", [name])
        }
        
        #deny[msg] {
        #  not exists_in_list(name, not_needed_for_jolokia)
        #  not jolokia_is_in_list(ports)
        #  msg = sprintf("image %v in deployment %v is missing jolokiaport", [first_container.image, name])
        #}
        
        required_labels {
        	input.review.object.metadata.labels["app.kubernetes.io/name"]
        	input.review.object.metadata.labels["app.kubernetes.io/instance"]
        	input.review.object.metadata.labels["app.kubernetes.io/version"]
        	input.review.object.metadata.labels["app.kubernetes.io/component"]
        	input.review.object.metadata.labels["app.kubernetes.io/part-of"]
        	input.review.object.metadata.labels["app.kubernetes.io/managed-by"]
        }
        
        # a list of ressources which needes a serviceaccount
        serviceaccount_needed = [
        	"unittest-ansparservice",
        	"unittest-authservice",
        	"unittest-certservice",
        	"unittest-mysql",
        ]
        
        allowed_kinds = [
        	"ConfigMap",
        	"Secret",
        	"Service",
        	"Deployment",
        	"PersistentVolume",
        	"PersistentVolumeClaim",
        	"HorizontalPodAutoscaler",
        	"Ingress",
        	"Job",
        	"Role",
        	"RoleBinding",
        	"ServiceAccount",
        	"PodDisruptionBudget",
        	"NetworkPolicy",
        	"Pod",
        	"PodSecurityPolicy",
        ]
        
        allowed_subject_kinds = [
        	"ServiceAccount",
        	"Group",
        ]
        
        trusted_registries = [
        	"luke19",
        	"curlimages",
        ]
        
        violation[{"msg": msg}] {
        	not required_labels
        	msg = sprintf("%s of kind %s must include Kubernetes recommended labels: https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/#labels", [name, input.review.object.kind])
        }
        
        exists_in_list(element, list) {
        	val := list[_]
        	element == val
        }
        
        violation[{"msg": msg}] {
        	val := input.review.object.kind
        	not exists_in_list(input.review.object.kind, allowed_kinds)
        
        	msg = sprintf("%v is not a allowed kind", [val])
        }
        
        startswith_in_list(element, list) {
        	startswith(element, list[_])
        }
